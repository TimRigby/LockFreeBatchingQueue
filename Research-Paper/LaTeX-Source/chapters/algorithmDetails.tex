
\setcounter{subsection}{0}
In this section we will cover how the Lock Free Queue With Batching algorithm works, and what underlying data structures are needed. Since the original implementation was done in C++, there is a couple slight modifications that we had to make to get our version working in Java. 

\begin{lstlisting} 
public class Node<T>    {T val; AtomicReference<Node<T>> next;}

public class Future<T> {T returnVal; boolean isDone;}

public class NodeWithCount<T> {Node<T> node; int count;}

public class FutureOp<T> {boolean isEnqueue; Future<T> future;}

public class NodeCountOrAnn {
    boolean isAnnouncement;
    NodeWithCount nodeWCount;
    Announcement announcement;
}


public class BatchRequest<T>{
    Node<T> firstEnq;
    Node<T> lastEnq;
    int numEnqs;
    int numDeqs;
    int numExcessDeqs;
}

public class NodeCountOrAnn {
    boolean isAnnouncement;
    NodeWithCount nodeWCount;
    Announcement announcement;
}

public class ThreadData<T> {
    LinkedList<Node<T>> opsQueue;
    Node<T> enqHead;
    Node<T> enqTail;
    int numEnqs;
    int numDeqs;
    int numExcessDeqs;
}\end{lstlisting}

\subsection{Data Structures}

\textit{4.1.1} Node Class:
The node class is a very standard implementation having a val and a reference to the next node.\newline

\textit{4.1.1} Future Class: The future class 



